#!/usr/bin/env python3
"""
Build a self-extracting installer for the Screen Recording Service.

Run this on YOUR machine (the admin machine) to generate a single install.sh
that you can host anywhere. On employee machines, just run:

    curl -sL https://yourserver.com/install.sh | bash

Usage:
    python3 build_installer.py \
        --credentials credentials.json \
        --drive-folder-id "1ABC...xyz" \
        --gemini-key "AIza..." \
        --xai-key "xai-..." \
        --openrouter-key "sk-or-..." \
        --output install.sh
"""

import argparse
import base64
import io
import os
import stat
import sys
import tarfile
from pathlib import Path

# Files to include in the installer bundle (relative to project root)
BUNDLE_FILES = [
    "requirements.txt",
    "screenrecord/__init__.py",
    "screenrecord/__main__.py",
    "screenrecord/main.py",
    "screenrecord/config_manager.py",
    "screenrecord/platform_utils.py",
    "screenrecord/recorder.py",
    "screenrecord/uploader.py",
    "screenrecord/analyzer.py",
    "screenrecord/rag_system.py",
    "screenrecord/encryption.py",
    "screenrecord/compliance.py",
    "screenrecord/heartbeat.py",
    "screenrecord/dashboard.py",
    "screenrecord/updater.py",
]

INSTALLER_TEMPLATE = r'''#!/bin/bash
# Screen Recording Service - Self-Extracting Installer
# Generated by build_installer.py
# Usage: curl -sL https://yourserver.com/install.sh | bash
set -euo pipefail

INSTALL_DIR="$HOME/.screenrecord"
PLIST_LABEL="com.screenrecord.service"

# ── Helpers ──────────────────────────────────────────────────────────────────

info()  {{ printf "  %s\n" "$1"; }}
ok()    {{ printf "  ✓ %s\n" "$1"; }}
fail()  {{ printf "  ✗ %s\n" "$1" >&2; exit 1; }}

# ── OS Detection ─────────────────────────────────────────────────────────────

detect_os() {{
    case "$(uname -s)" in
        Darwin)  OS="macos" ;;
        MINGW*|MSYS*|CYGWIN*)  OS="windows" ;;
        *)       fail "Unsupported operating system: $(uname -s)" ;;
    esac
}}

# ── Prerequisites ────────────────────────────────────────────────────────────

check_python() {{
    if command -v python3 &>/dev/null; then
        PY_VERSION=$(python3 -c "import sys; print(f'{{sys.version_info.major}}.{{sys.version_info.minor}}')")
        PY_MAJOR=$(echo "$PY_VERSION" | cut -d. -f1)
        PY_MINOR=$(echo "$PY_VERSION" | cut -d. -f2)
        if [ "$PY_MAJOR" -ge 3 ] && [ "$PY_MINOR" -ge 10 ]; then
            ok "Python $PY_VERSION"
            return 0
        fi
    fi
    fail "Python 3.10+ is required but not found. Install from https://python.org"
}}

check_ffmpeg() {{
    if command -v ffmpeg &>/dev/null; then
        ok "FFmpeg found"
        return 0
    fi

    info "FFmpeg not found, attempting to install..."
    if [ "$OS" = "macos" ]; then
        if command -v brew &>/dev/null; then
            brew install ffmpeg --quiet 2>/dev/null
            if command -v ffmpeg &>/dev/null; then
                ok "FFmpeg installed via Homebrew"
                return 0
            fi
        fi
    fi
    fail "Could not install FFmpeg. Install it manually: brew install ffmpeg"
}}

# ── Auto-detect Employee Info ────────────────────────────────────────────────

detect_employee_name() {{
    if [ "$OS" = "macos" ]; then
        EMPLOYEE_NAME=$(dscl . -read "/Users/$(whoami)" RealName 2>/dev/null | tail -1 | xargs)
    fi
    if [ -z "${{EMPLOYEE_NAME:-}}" ] || [ "$EMPLOYEE_NAME" = "$(whoami)" ]; then
        EMPLOYEE_NAME=$(whoami)
    fi
}}

detect_computer_name() {{
    COMPUTER_NAME=$(hostname -s 2>/dev/null || hostname)
}}

# ── Extract Payload ──────────────────────────────────────────────────────────

extract_payload() {{
    mkdir -p "$INSTALL_DIR"
    mkdir -p "$INSTALL_DIR/recordings"
    mkdir -p "$INSTALL_DIR/logs"

    # Decode and extract the embedded tar.gz payload
    echo "{payload_b64}" | base64 -d | tar xz -C "$INSTALL_DIR"
    ok "Files extracted"
}}

# ── Write Credentials & Config ───────────────────────────────────────────────

write_secrets() {{
    # Service account credentials
    echo "{credentials_b64}" | base64 -d > "$INSTALL_DIR/credentials.json"
    chmod 600 "$INSTALL_DIR/credentials.json"

    # AES-256 encryption key
    echo "{encryption_key_b64}" | base64 -d > "$INSTALL_DIR/encryption.key"
    chmod 400 "$INSTALL_DIR/encryption.key"

    ok "Credentials and encryption key written"
}}

write_config() {{
    cat > "$INSTALL_DIR/config.yaml" <<YAML
client_name: "{client_name}"
employee_name: "${{EMPLOYEE_NAME}}"
computer_name: "${{COMPUTER_NAME}}"

recording:
  fps: 5
  crf: 28
  segment_duration: 3600
  output_dir: "${{INSTALL_DIR}}/recordings"
  audio_device: ""

google_drive:
  credentials_file: "${{INSTALL_DIR}}/credentials.json"
  root_folder_id: "{drive_folder_id}"

encryption:
  key_file: "${{INSTALL_DIR}}/encryption.key"

analysis:
  enabled: {analysis_enabled}
  gemini_api_key: "{gemini_key}"
  xai_api_key: "{xai_key}"
  openrouter_api_key: "{openrouter_key}"

rag:
  enabled: {rag_enabled}
  db_path: "${{INSTALL_DIR}}/rag_db"
  synthesis_interval: 3600
  bible_path: "${{INSTALL_DIR}}/company_operations_bible.md"
YAML
    ok "Config generated for ${{EMPLOYEE_NAME}} on ${{COMPUTER_NAME}}"
}}

# ── Install Dependencies ─────────────────────────────────────────────────────

install_deps() {{
    info "Installing Python dependencies (this may take a minute)..."
    pip3 install -r "$INSTALL_DIR/requirements.txt" --quiet --disable-pip-version-check 2>/dev/null
    ok "Dependencies installed"
}}

# ── Consent ──────────────────────────────────────────────────────────────────

record_consent() {{
    cat > "$INSTALL_DIR/consent_records.json" <<JSON
[
  {{
    "timestamp": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")",
    "employee_name": "${{EMPLOYEE_NAME}}",
    "consented_by": "system_administrator",
    "consent_text": "Screen recording authorized by company administrator during automated deployment. All recordings encrypted with AES-256-GCM. HIPAA compliance acknowledged."
  }}
]
JSON
    chmod 600 "$INSTALL_DIR/consent_records.json"
}}

# ── Auto-start ───────────────────────────────────────────────────────────────

setup_autostart() {{
    if [ "$OS" != "macos" ]; then
        info "Auto-start: manual setup required on $OS"
        return 0
    fi

    PLIST_PATH="$HOME/Library/LaunchAgents/${{PLIST_LABEL}}.plist"
    mkdir -p "$HOME/Library/LaunchAgents"

    PYTHON_PATH=$(which python3)

    cat > "$PLIST_PATH" <<PLIST
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>${{PLIST_LABEL}}</string>
    <key>ProgramArguments</key>
    <array>
        <string>${{PYTHON_PATH}}</string>
        <string>-m</string>
        <string>screenrecord</string>
        <string>--config</string>
        <string>${{INSTALL_DIR}}/config.yaml</string>
    </array>
    <key>WorkingDirectory</key>
    <string>${{INSTALL_DIR}}</string>
    <key>EnvironmentVariables</key>
    <dict>
        <key>PATH</key>
        <string>/usr/local/bin:/usr/bin:/bin:/opt/homebrew/bin</string>
        <key>PYTHONPATH</key>
        <string>${{INSTALL_DIR}}</string>
    </dict>
    <key>RunAtLoad</key>
    <true/>
    <key>KeepAlive</key>
    <true/>
    <key>StandardOutPath</key>
    <string>${{INSTALL_DIR}}/logs/stdout.log</string>
    <key>StandardErrorPath</key>
    <string>${{INSTALL_DIR}}/logs/stderr.log</string>
</dict>
</plist>
PLIST

    launchctl unload "$PLIST_PATH" 2>/dev/null || true
    launchctl load "$PLIST_PATH"
    ok "Auto-start configured (launchd)"
}}

# ── Start ────────────────────────────────────────────────────────────────────

start_service() {{
    if [ "$OS" = "macos" ]; then
        launchctl start "$PLIST_LABEL" 2>/dev/null || true
    else
        cd "$INSTALL_DIR" && nohup python3 -m screenrecord --config "$INSTALL_DIR/config.yaml" \
            >> "$INSTALL_DIR/logs/stdout.log" 2>> "$INSTALL_DIR/logs/stderr.log" &
    fi
    ok "Service started"
}}

# ── Main ─────────────────────────────────────────────────────────────────────

main() {{
    echo ""
    echo "  Screen Recording Service - Installing..."
    echo ""

    detect_os
    check_python
    check_ffmpeg
    detect_employee_name
    detect_computer_name

    extract_payload
    write_secrets
    write_config
    install_deps
    record_consent
    setup_autostart
    start_service

    echo ""
    echo "  ────────────────────────────────────────────"
    echo "  ✓ Installed successfully"
    echo "    Employee:    ${{EMPLOYEE_NAME}}"
    echo "    Computer:    ${{COMPUTER_NAME}}"
    echo "    Install dir: ${{INSTALL_DIR}}"
    echo "    Status:      Recording"
    echo ""
    echo "    Starts automatically on login."
    echo "  ────────────────────────────────────────────"
    echo ""
}}

main
'''


def build_payload(project_root: Path, slim: bool = False) -> str:
    """Bundle project files into a base64-encoded tar.gz string.

    When *slim* is True, ``requirements-core.txt`` is bundled as
    ``requirements.txt`` (smaller deps, no analysis/RAG packages).
    """
    buf = io.BytesIO()
    with tarfile.open(fileobj=buf, mode="w:gz") as tar:
        for rel_path in BUNDLE_FILES:
            # Swap requirements file when running in slim mode
            if slim and rel_path == "requirements.txt":
                core_path = project_root / "requirements-core.txt"
                if core_path.exists():
                    tar.add(str(core_path), arcname="requirements.txt")
                    continue
            full_path = project_root / rel_path
            if not full_path.exists():
                print(f"WARNING: Missing file: {full_path}", file=sys.stderr)
                continue
            tar.add(str(full_path), arcname=rel_path)
    return base64.b64encode(buf.getvalue()).decode("ascii")


def generate_encryption_key() -> str:
    """Generate a new AES-256 key and return it base64-encoded."""
    key = os.urandom(32)
    return base64.b64encode(key).decode("ascii")


def main():
    parser = argparse.ArgumentParser(
        description="Build a self-extracting installer for the Screen Recording Service.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Example:
    python3 build_installer.py \\
        --credentials credentials.json \\
        --drive-folder-id "1ABCxyz..." \\
        --gemini-key "AIza..." \\
        --xai-key "xai-..." \\
        --openrouter-key "sk-or-..." \\
        --output install.sh

Then host install.sh anywhere and run on employee machines:
    curl -sL https://yourserver.com/install.sh | bash
        """,
    )
    parser.add_argument(
        "--credentials",
        required=True,
        help="Path to Google service account credentials.json",
    )
    parser.add_argument(
        "--drive-folder-id",
        required=True,
        help="Google Drive folder ID for uploads",
    )
    parser.add_argument(
        "--client-name",
        default="",
        help="Client/practice name (e.g., 'Texas Sinus Center'). Creates a top-level folder on Drive.",
    )
    parser.add_argument("--gemini-key", default="", help="Gemini API key")
    parser.add_argument("--xai-key", default="", help="xAI (Grok) API key")
    parser.add_argument("--openrouter-key", default="", help="OpenRouter API key")
    parser.add_argument(
        "--no-analysis",
        action="store_true",
        help="Disable video analysis and RAG (no API keys needed). Record + upload only.",
    )
    parser.add_argument(
        "--encryption-key",
        default="",
        help="Base64-encoded AES-256 key. If omitted, a new key is generated.",
    )
    parser.add_argument(
        "--output",
        default="install.sh",
        help="Output path for the installer script (default: install.sh)",
    )

    args = parser.parse_args()

    project_root = Path(__file__).resolve().parent

    # Load credentials
    creds_path = Path(args.credentials)
    if not creds_path.is_file():
        print(f"Error: Credentials file not found: {creds_path}", file=sys.stderr)
        sys.exit(1)
    credentials_b64 = base64.b64encode(creds_path.read_bytes()).decode("ascii")

    # Encryption key
    if args.encryption_key:
        encryption_key_b64 = args.encryption_key
    else:
        encryption_key_b64 = generate_encryption_key()
        # Save the key locally so the admin can decrypt files later
        key_save_path = project_root / "encryption.key"
        if key_save_path.exists():
            os.chmod(key_save_path, 0o644)  # Make writable before overwrite
        key_save_path.write_text(encryption_key_b64)
        os.chmod(key_save_path, 0o400)
        print(f"Generated new encryption key -> {key_save_path}")
        print("KEEP THIS FILE SAFE. You need it to decrypt recordings.")
        print()

    # Determine analysis/RAG state
    analysis_disabled = args.no_analysis or not any([
        args.gemini_key, args.xai_key, args.openrouter_key
    ])
    if analysis_disabled:
        print("Analysis and RAG disabled (record + upload only)")

    # Bundle project files (use slim requirements when analysis is disabled)
    print("Bundling project files...")
    payload_b64 = build_payload(project_root, slim=analysis_disabled)
    print(f"Payload size: {len(payload_b64) // 1024} KB (base64)")

    # Generate the installer script
    installer = INSTALLER_TEMPLATE.format(
        payload_b64=payload_b64,
        credentials_b64=credentials_b64,
        encryption_key_b64=encryption_key_b64,
        drive_folder_id=args.drive_folder_id,
        client_name=args.client_name or "",
        gemini_key=args.gemini_key or "",
        xai_key=args.xai_key or "",
        openrouter_key=args.openrouter_key or "",
        analysis_enabled="false" if analysis_disabled else "true",
        rag_enabled="false" if analysis_disabled else "true",
    )

    output_path = Path(args.output)
    output_path.write_text(installer, encoding="utf-8")
    os.chmod(output_path, stat.S_IRWXU | stat.S_IRGRP | stat.S_IXGRP)

    print()
    print(f"Installer written to: {output_path}")
    print(f"Size: {output_path.stat().st_size // 1024} KB")
    print()
    print("To deploy, host the file and run on each employee machine:")
    print(f"  curl -sL https://yourserver.com/{output_path.name} | bash")
    print()
    print("Or copy it directly and run:")
    print(f"  bash {output_path.name}")


if __name__ == "__main__":
    main()
